type UserInfoExt = 
 record {
   id: text;
   name: text;
   tokens: vec TokenIndex;
 };
type User = 
 variant {
   address: AccountIdentifier;
   "principal": principal;
 };
type TransferResponse = 
 variant {
   err:
    variant {
      CannotNotify: AccountIdentifier;
      InsufficientBalance;
      InvalidToken: TokenIdentifier;
      Other: text;
      Rejected;
      Unauthorized: AccountIdentifier;
    };
   ok: Balance;
 };
type TransferRequest = 
 record {
   amount: Balance;
   from: User;
   memo: Memo;
   notify: bool;
   subaccount: opt SubAccount;
   to: User;
   token: TokenIdentifier;
 };
type TokenIndex__1 = nat32;
type TokenIndex = nat32;
type TokenIdentifier__1 = text;
type TokenIdentifier = text;
type SubAccount = vec nat8;
type Result_5 = 
 variant {
   err: CommonError;
   ok: vec MetadataExt;
 };
type Result_4 = 
 variant {
   err: CommonError;
   ok: MetadataExt;
 };
type Result_3 = 
 variant {
   err: CommonError;
   ok: nat;
 };
type Result_2 = 
 variant {
   err: CommonError;
   ok: vec record {
             AccountIdentifier__1;
             Balance__1;
           };
 };
type Result_1 = 
 variant {
   err: text;
   ok: bool;
 };
type Result = 
 variant {
   err: CommonError;
   ok: Balance__1;
 };
type MetadataExt = 
 record {
   attributes: vec AttributeMeta;
   description: text;
   detail: DetailNFT;
   image: text;
   name: text;
 };
type Memo = blob;
type Extension = text;
type DetailNFT = 
 variant {
   land:
    record {
      gold: float64;
      leaf: float64;
      nestStaked: opt TokenIndex;
      wood: float64;
    };
   nest: record {
           level: nat;
           queenIn: opt TokenIndex;
         };
   queen: record {level: nat;};
   worker: record {level: nat;};
 };
type CommonError__1 = 
 variant {
   InvalidToken: TokenIdentifier;
   Other: text;
 };
type CommonError = 
 variant {
   InvalidToken: TokenIdentifier;
   Other: text;
 };
type Balance__1 = nat;
type BalanceResponse = 
 variant {
   err: CommonError__1;
   ok: Balance;
 };
type BalanceRequest = 
 record {
   token: TokenIdentifier;
   user: User;
 };
type Balance = nat;
type AttributeMeta = 
 record {
   max: opt text;
   min: opt text;
   trait_type: text;
   value: text;
 };
type AntKingdoms = 
 service {
   acceptCycles: () -> ();
   allRegistry: () ->
    (vec
      record {
        TokenIndex__1;
        vec record {
              AccountIdentifier__1;
              Balance__1;
            };
      }) query;
   availableCycles: () -> (nat) query;
   balance: (BalanceRequest) -> (BalanceResponse) query;
   changeAdmin: (principal) -> ();
   claiming: () -> (Result_1);
   extensions: () -> (vec Extension) query;
   getTokensMetadata: () -> (vec MetadataExt);
   getUserInfo: (AccountIdentifier__1) -> (UserInfoExt) query;
   getUserTokens: (AccountIdentifier__1) -> (Result_5) query;
   metadata: (TokenIdentifier__1) -> (Result_4) query;
   numberOfTokenHolders: (TokenIdentifier__1) -> (Result_3) query;
   numberOfTokens: () -> (nat) query;
   registry: (TokenIdentifier__1) -> (Result_2) query;
   setTokensMetadata: (vec MetadataExt) -> (Result_1);
   supply: (TokenIdentifier__1) -> (Result) query;
   transfer: (TransferRequest) -> (TransferResponse);
 };
type AccountIdentifier__1 = text;
type AccountIdentifier = text;
service : (principal) -> AntKingdoms
